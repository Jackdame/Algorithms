# 树状数组
## 主要用途：
1. 单点/区间查询
2. 单点/区间维护

## 核心原理：
### lowbit(x) = x & -x 表示找到x二进制中最后一个1加上后面的所有0所表示的数

假设原数组为a，树状数组为tree，两者关系是怎么样的呢
如图：
![](C:\Users\35134\Pictures\新建画布1.png "关系图")
### 这样我们可以知道tree的管理界限是多少，首先x决定了tree[x]的右界，其次其左界由lowbit(x)决定，即tree[x] = sum(x-lowbit(x)+1,x)。他的长度为lowbit(x)。

------
为什么要这样做呢，好处是什么呢。
一般而言，查询前缀和sum复杂度是O(n)级别的，但是用tree可以降到O(logn)
过程是怎么实现的呢：
```c
int sum(int x){
	int ans = 0;
	while(x>0){
		ans+=tree[x];
		x-=lowbit(x);
	}
	return ans;
}
```
我们知道tree[x]是x-lowbit+1到x的和，我们不停地往前找和即可，通过二进制拆分和倍增的思想，只需要找logn次。
同理的，维护单点修改即其逆操作
```c
void update(int x,int d){
	while(x<=n){
		tree[x]+=d;
		x+=lowbit(x);
	}
}
```
从x开始向后找所有包含x的tree，随后全体加上d
## 如何区间修改：
![](C:\Users\35134\Pictures\新建画布1.jpg "差分思想")
```c
int L,R,d;
update(L,d),update(R+1,-d);//区间修改
cout<<sum[i];//单点查询
```

## 关于同时区间修改和查询
![](C:\Users\35134\Pictures\新建画布3.jpg "推导")
通过上面分析，我们只需要维护两个tree实现即可
```c
int tree1[N],tree2[N];
for(int i=1;i<=n;++i){
	cin >> a[i];
	update1(i,a[i]-d),update(i,(i-1)*(a[i]-d));
	d = a[i];
}//差分数组初始化
cin >> L >> R >> s;
update1(L,s),update1(R+1,-s);
update2(L,s*(L-1)),update2(R+1,-s*R);
//区间修改
cin >> L >> R;
cout<< R*sum1(R) - sum2(R) - (L-1)*sum1(L-1) + sum2(L-1);
//区间查询
```