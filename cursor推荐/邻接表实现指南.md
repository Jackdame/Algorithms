# é‚»æ¥è¡¨å®ç°æŒ‡å—

## ğŸ“š ä»€ä¹ˆæ˜¯é‚»æ¥è¡¨ï¼Ÿ

é‚»æ¥è¡¨æ˜¯å›¾çš„ä¸€ç§å­˜å‚¨æ–¹å¼ï¼Œç”¨é“¾è¡¨æˆ–æ•°ç»„åˆ—è¡¨å­˜å‚¨æ¯ä¸ªé¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹ã€‚

**ä¼˜ç‚¹**ï¼š
- èŠ‚çœç©ºé—´ï¼ˆåªå­˜å‚¨å­˜åœ¨çš„è¾¹ï¼‰
- é€‚åˆç¨€ç–å›¾
- éå†æŸä¸ªé¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥ç‚¹æ•ˆç‡é«˜

**ç¼ºç‚¹**ï¼š
- åˆ¤æ–­ä¸¤ç‚¹æ˜¯å¦ç›¸é‚»éœ€è¦éå†
- å®ç°ç›¸å¯¹å¤æ‚

---

## ğŸ”§ å®ç°æ–¹æ³•

### æ–¹æ³•1ï¼švector<vector<int>>ï¼ˆæœ€å¸¸ç”¨ï¼Œæ¨èï¼‰

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int MAXN = 100005;
vector<vector<int>> g(MAXN);  // é‚»æ¥è¡¨

// æ·»åŠ è¾¹ï¼ˆæ— å‘å›¾ï¼‰
void addEdge(int u, int v) {
    g[u].push_back(v);
    g[v].push_back(u);  // æ— å‘å›¾éœ€è¦åŒå‘æ·»åŠ 
}

// æ·»åŠ è¾¹ï¼ˆæœ‰å‘å›¾ï¼‰
void addDirectedEdge(int u, int v) {
    g[u].push_back(v);  // åªæ·»åŠ  u -> v
}

// éå†å›¾ï¼ˆDFSï¼‰
void dfs(int u, vector<bool>& vis) {
    vis[u] = true;
    cout << u << " ";
    
    for (int v : g[u]) {
        if (!vis[v]) {
            dfs(v, vis);
        }
    }
}

// éå†å›¾ï¼ˆBFSï¼‰
void bfs(int start) {
    vector<bool> vis(MAXN, false);
    queue<int> q;
    
    q.push(start);
    vis[start] = true;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        cout << u << " ";
        
        for (int v : g[u]) {
            if (!vis[v]) {
                vis[v] = true;
                q.push(v);
            }
        }
    }
}

int main() {
    int n, m;  // nä¸ªé¡¶ç‚¹ï¼Œmæ¡è¾¹
    cin >> n >> m;
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        addEdge(u, v);  // æ— å‘å›¾
    }
    
    // DFSéå†
    vector<bool> vis(MAXN, false);
    dfs(1, vis);
    
    return 0;
}
```

### æ–¹æ³•2ï¼švector<int> g[MAXN]ï¼ˆæ•°ç»„å½¢å¼ï¼‰

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int MAXN = 100005;
vector<int> g[MAXN];  // é‚»æ¥è¡¨æ•°ç»„

// æ·»åŠ è¾¹ï¼ˆæ— å‘å›¾ï¼‰
void addEdge(int u, int v) {
    g[u].push_back(v);
    g[v].push_back(u);
}

// éå†
void dfs(int u, vector<bool>& vis) {
    vis[u] = true;
    for (int v : g[u]) {
        if (!vis[v]) {
            dfs(v, vis);
        }
    }
}
```

### æ–¹æ³•3ï¼šå¸¦æƒé‡çš„é‚»æ¥è¡¨

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int MAXN = 100005;

// æ–¹æ³•3.1ï¼šä½¿ç”¨ pair
vector<vector<pair<int, int>>> g(MAXN);  // {é‚»æ¥ç‚¹, æƒé‡}

void addWeightedEdge(int u, int v, int w) {
    g[u].push_back({v, w});
    g[v].push_back({u, w});  // æ— å‘å›¾
}

// éå†
void dfs(int u, vector<bool>& vis) {
    vis[u] = true;
    for (auto [v, w] : g[u]) {
        if (!vis[v]) {
            cout << u << " -> " << v << " (weight: " << w << ")" << endl;
            dfs(v, vis);
        }
    }
}

// æ–¹æ³•3.2ï¼šä½¿ç”¨ç»“æ„ä½“
struct Edge {
    int to, weight;
    Edge(int t, int w) : to(t), weight(w) {}
};

vector<vector<Edge>> graph(MAXN);

void addEdgeStruct(int u, int v, int w) {
    graph[u].push_back(Edge(v, w));
    graph[v].push_back(Edge(u, w));
}
```

### æ–¹æ³•4ï¼šé“¾è¡¨å®ç°ï¼ˆä¸å¸¸ç”¨ï¼Œä½†å¯ä»¥å­¦ä¹ ï¼‰

```cpp
#include <iostream>
using namespace std;

struct Node {
    int vertex;
    Node* next;
    Node(int v) : vertex(v), next(nullptr) {}
};

const int MAXN = 100005;
Node* adj[MAXN];  // é‚»æ¥è¡¨

void addEdge(int u, int v) {
    Node* node = new Node(v);
    node->next = adj[u];
    adj[u] = node;
    
    // æ— å‘å›¾
    node = new Node(u);
    node->next = adj[v];
    adj[v] = node;
}

void printGraph(int n) {
    for (int i = 1; i <= n; i++) {
        cout << i << ": ";
        Node* curr = adj[i];
        while (curr != nullptr) {
            cout << curr->vertex << " ";
            curr = curr->next;
        }
        cout << endl;
    }
}
```

---

## ğŸ“ å®Œæ•´ç¤ºä¾‹ï¼šæ— å‘å›¾

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

const int MAXN = 100005;
vector<vector<int>> g(MAXN);

// æ·»åŠ è¾¹
void addEdge(int u, int v) {
    g[u].push_back(v);
    g[v].push_back(u);
}

// DFSéå†
void dfs(int u, vector<bool>& vis) {
    vis[u] = true;
    cout << u << " ";
    
    for (int v : g[u]) {
        if (!vis[v]) {
            dfs(v, vis);
        }
    }
}

// BFSéå†
void bfs(int start) {
    vector<bool> vis(MAXN, false);
    queue<int> q;
    
    q.push(start);
    vis[start] = true;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        cout << u << " ";
        
        for (int v : g[u]) {
            if (!vis[v]) {
                vis[v] = true;
                q.push(v);
            }
        }
    }
}

int main() {
    int n, m;
    cin >> n >> m;
    
    // è¯»å…¥è¾¹
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        addEdge(u, v);
    }
    
    // DFSéå†
    cout << "DFS: ";
    vector<bool> vis(MAXN, false);
    dfs(1, vis);
    cout << endl;
    
    // BFSéå†
    cout << "BFS: ";
    bfs(1);
    cout << endl;
    
    return 0;
}
```

**è¾“å…¥ç¤ºä¾‹**ï¼š
```
5 4
1 2
1 3
2 4
3 5
```

**è¾“å‡º**ï¼š
```
DFS: 1 2 4 3 5
BFS: 1 2 3 4 5
```

---

## ğŸ“ å®Œæ•´ç¤ºä¾‹ï¼šæœ‰å‘å›¾

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int MAXN = 100005;
vector<vector<int>> g(MAXN);

// æ·»åŠ æœ‰å‘è¾¹
void addDirectedEdge(int u, int v) {
    g[u].push_back(v);  // åªæ·»åŠ  u -> v
}

// æ‰“å°å›¾
void printGraph(int n) {
    for (int i = 1; i <= n; i++) {
        cout << i << ": ";
        for (int v : g[i]) {
            cout << v << " ";
        }
        cout << endl;
    }
}

int main() {
    int n, m;
    cin >> n >> m;
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        addDirectedEdge(u, v);
    }
    
    printGraph(n);
    return 0;
}
```

---

## ğŸ“ å®Œæ•´ç¤ºä¾‹ï¼šå¸¦æƒå›¾

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

const int MAXN = 100005;
vector<vector<pair<int, int>>> g(MAXN);  // {é‚»æ¥ç‚¹, æƒé‡}

// æ·»åŠ å¸¦æƒè¾¹
void addWeightedEdge(int u, int v, int w) {
    g[u].push_back({v, w});
    g[v].push_back({u, w});  // æ— å‘å›¾
}

// Dijkstraç®—æ³•ï¼ˆæœ€çŸ­è·¯å¾„ï¼‰
void dijkstra(int start, int n) {
    vector<int> dist(n + 1, INT_MAX);
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    
    dist[start] = 0;
    pq.push({0, start});
    
    while (!pq.empty()) {
        int u = pq.top().second;
        int d = pq.top().first;
        pq.pop();
        
        if (d > dist[u]) continue;
        
        for (auto [v, w] : g[u]) {
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
    
    // è¾“å‡ºæœ€çŸ­è·ç¦»
    for (int i = 1; i <= n; i++) {
        cout << "dist[" << i << "] = " << dist[i] << endl;
    }
}

int main() {
    int n, m;
    cin >> n >> m;
    
    for (int i = 0; i < m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        addWeightedEdge(u, v, w);
    }
    
    dijkstra(1, n);
    return 0;
}
```

---

## ğŸ¯ å¸¸ç”¨æ“ä½œ

### 1. æ£€æŸ¥ä¸¤ç‚¹æ˜¯å¦ç›¸é‚»

```cpp
bool isAdjacent(int u, int v) {
    for (int neighbor : g[u]) {
        if (neighbor == v) {
            return true;
        }
    }
    return false;
}
```

### 2. è·å–é¡¶ç‚¹çš„åº¦æ•°

```cpp
int getDegree(int u) {
    return g[u].size();
}
```

### 3. åˆ é™¤è¾¹

```cpp
void removeEdge(int u, int v) {
    // åˆ é™¤ u -> v
    g[u].erase(
        remove(g[u].begin(), g[u].end(), v),
        g[u].end()
    );
    
    // æ— å‘å›¾ï¼šåˆ é™¤ v -> u
    g[v].erase(
        remove(g[v].begin(), g[v].end(), u),
        g[v].end()
    );
}
```

### 4. æ¸…ç©ºå›¾

```cpp
void clearGraph(int n) {
    for (int i = 1; i <= n; i++) {
        g[i].clear();
    }
}
```

---

## ğŸ“Š å¤æ‚åº¦åˆ†æ

| æ“ä½œ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ |
|------|-----------|-----------|
| æ·»åŠ è¾¹ | O(1) | O(1) |
| éå†é‚»æ¥ç‚¹ | O(degree) | O(1) |
| æ£€æŸ¥æ˜¯å¦ç›¸é‚» | O(degree) | O(1) |
| å­˜å‚¨ç©ºé—´ | - | O(V + E) |

---

## ğŸ’¡ ä½¿ç”¨å»ºè®®

1. **æ— å‘å›¾**ï¼šä½¿ç”¨ `vector<vector<int>>`ï¼Œæ·»åŠ è¾¹æ—¶åŒå‘æ·»åŠ 
2. **æœ‰å‘å›¾**ï¼šåªæ·»åŠ ä¸€ä¸ªæ–¹å‘çš„è¾¹
3. **å¸¦æƒå›¾**ï¼šä½¿ç”¨ `vector<vector<pair<int, int>>>`
4. **ç¨€ç–å›¾**ï¼šé‚»æ¥è¡¨æ¯”é‚»æ¥çŸ©é˜µæ›´èŠ‚çœç©ºé—´
5. **ç¨ å¯†å›¾**ï¼šå¯ä»¥è€ƒè™‘é‚»æ¥çŸ©é˜µ

---

## ğŸ”— ç›¸å…³é¢˜ç›®

- **500A - New Year Transportation**ï¼šç®€å•å›¾éå†
- **580C - Kefa and Park**ï¼šæ ‘ä¸Šçš„DFS
- **520B - Two Buttons**ï¼šBFSæœ€çŸ­è·¯å¾„
- **217A - Ice Skating**ï¼šè¿é€šå—













