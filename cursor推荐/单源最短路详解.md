# å•æºæœ€çŸ­è·¯å¾„é—®é¢˜è¯¦è§£

## ğŸ“š ç®—æ³•å¯¹æ¯”

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ | èƒ½å¦å¤„ç†è´Ÿæƒè¾¹ | èƒ½å¦æ£€æµ‹è´Ÿç¯ |
|------|-----------|---------|--------------|-------------|
| **Dijkstra** | O((V+E)log V) | éè´Ÿæƒè¾¹ | âŒ | âŒ |
| **Bellman-Ford** | O(VE) | é€šç”¨ | âœ… | âœ… |
| **SPFA** | å¹³å‡ O(E)ï¼Œæœ€å O(VE) | é€šç”¨ï¼ˆæ¨èï¼‰ | âœ… | âœ… |

---

## ğŸ”§ ç®—æ³•è¯¦è§£

### 1. Dijkstraç®—æ³•

**é€‚ç”¨æ¡ä»¶**ï¼š
- âœ… éè´Ÿæƒè¾¹
- âœ… æœ‰å‘å›¾/æ— å‘å›¾
- âŒ ä¸èƒ½å¤„ç†è´Ÿæƒè¾¹
- âŒ ä¸èƒ½æ£€æµ‹è´Ÿç¯

**æ ¸å¿ƒæ€æƒ³**ï¼š
- æ¯æ¬¡é€‰æ‹©è·ç¦»èµ·ç‚¹æœ€è¿‘çš„æœªè®¿é—®ç‚¹
- ç”¨è¯¥ç‚¹æ›´æ–°å…¶ä»–ç‚¹çš„è·ç¦»
- ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–

**ä»£ç æ¨¡æ¿**ï¼š
```cpp
vector<int> dijkstra(int start, int n) {
    vector<int> dist(n + 1, INF);
    vector<bool> vis(n + 1, false);
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    
    dist[start] = 0;
    pq.push({0, start});
    
    while (!pq.empty()) {
        int u = pq.top().second;
        pq.pop();
        
        if (vis[u]) continue;  // å¤„ç†è‡ªç¯å’Œé‡è¾¹
        vis[u] = true;
        
        for (const Edge& e : g[u]) {
            int v = e.to, w = e.weight;
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
    
    return dist;
}
```

---

### 2. Bellman-Fordç®—æ³•

**é€‚ç”¨æ¡ä»¶**ï¼š
- âœ… å¯ä»¥å¤„ç†è´Ÿæƒè¾¹
- âœ… å¯ä»¥æ£€æµ‹è´Ÿç¯
- âœ… å¯ä»¥å¤„ç†è‡ªç¯
- âš ï¸ æ•ˆç‡è¾ƒä½

**æ ¸å¿ƒæ€æƒ³**ï¼š
- å¯¹æ¯æ¡è¾¹æ¾å¼› n-1 æ¬¡
- å¦‚æœç¬¬ n æ¬¡è¿˜èƒ½æ¾å¼›ï¼Œè¯´æ˜å­˜åœ¨è´Ÿç¯

**ä»£ç æ¨¡æ¿**ï¼š
```cpp
bool bellmanFord(int start, int n, vector<int>& dist) {
    dist.assign(n + 1, INF);
    dist[start] = 0;
    
    // æ¾å¼› n-1 æ¬¡
    for (int i = 0; i < n - 1; i++) {
        for (const Edge& e : edges) {
            if (dist[e.from] != INF && dist[e.from] + e.weight < dist[e.to]) {
                dist[e.to] = dist[e.from] + e.weight;
            }
        }
    }
    
    // æ£€æµ‹è´Ÿç¯
    for (const Edge& e : edges) {
        if (dist[e.from] != INF && dist[e.from] + e.weight < dist[e.to]) {
            return false;  // å­˜åœ¨è´Ÿç¯
        }
    }
    
    return true;
}
```

---

### 3. SPFAç®—æ³•ï¼ˆæ¨èï¼‰

**é€‚ç”¨æ¡ä»¶**ï¼š
- âœ… å¯ä»¥å¤„ç†è´Ÿæƒè¾¹
- âœ… å¯ä»¥æ£€æµ‹è´Ÿç¯
- âœ… å¯ä»¥å¤„ç†è‡ªç¯
- âœ… æ•ˆç‡æ¯”Bellman-Fordé«˜

**æ ¸å¿ƒæ€æƒ³**ï¼š
- Bellman-Fordçš„ä¼˜åŒ–ç‰ˆæœ¬
- åªå¯¹å¯èƒ½æ›´æ–°çš„ç‚¹è¿›è¡Œæ¾å¼›
- ä½¿ç”¨é˜Ÿåˆ—ç»´æŠ¤å¾…å¤„ç†çš„ç‚¹

**ä»£ç æ¨¡æ¿**ï¼š
```cpp
bool spfa(int start, int n, vector<int>& dist) {
    dist.assign(n + 1, INF);
    vector<int> cnt(n + 1, 0);
    vector<bool> inQueue(n + 1, false);
    
    queue<int> q;
    dist[start] = 0;
    q.push(start);
    inQueue[start] = true;
    cnt[start] = 1;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        inQueue[u] = false;
        
        for (const Edge& e : g[u]) {
            int v = e.to, w = e.weight;
            
            if (dist[u] != INF && dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                
                if (!inQueue[v]) {
                    q.push(v);
                    inQueue[v] = true;
                    cnt[v]++;
                    
                    // æ£€æµ‹è´Ÿç¯ï¼šå…¥é˜Ÿæ¬¡æ•°è¶…è¿‡n
                    if (cnt[v] > n) {
                        return false;
                    }
                }
            }
        }
    }
    
    return true;
}
```

---

## ğŸ¯ ç‰¹æ®Šæƒ…å†µå¤„ç†

### 1. è‡ªç¯å¤„ç†

**æ­£æƒè‡ªç¯**ï¼š
- ä¸å½±å“æœ€çŸ­è·¯å¾„
- ç®—æ³•è‡ªåŠ¨å¤„ç†ï¼ˆä¼šè¢«è·³è¿‡ï¼‰

**è´Ÿæƒè‡ªç¯**ï¼š
- ä¼šå¯¼è‡´è´Ÿç¯
- éœ€è¦æ£€æµ‹å¹¶æŠ¥å‘Š

```cpp
bool hasNegativeSelfLoop(int n) {
    for (int u = 1; u <= n; u++) {
        for (const Edge& e : g[u]) {
            if (e.to == u && e.weight < 0) {
                return true;  // å­˜åœ¨è´Ÿæƒè‡ªç¯
            }
        }
    }
    return false;
}
```

### 2. è´Ÿç¯æ£€æµ‹

**æ–¹æ³•1ï¼šSPFAæ£€æµ‹**
```cpp
if (cnt[v] > n) {
    return false;  // å­˜åœ¨è´Ÿç¯
}
```

**æ–¹æ³•2ï¼šBellman-Fordæ£€æµ‹**
```cpp
// ç¬¬næ¬¡æ¾å¼›ï¼Œå¦‚æœè¿˜èƒ½æ¾å¼›ï¼Œè¯´æ˜å­˜åœ¨è´Ÿç¯
for (const Edge& e : edges) {
    if (dist[e.from] != INF && dist[e.from] + e.weight < dist[e.to]) {
        return false;  // å­˜åœ¨è´Ÿç¯
    }
}
```

### 3. é‡è¾¹å¤„ç†

**Dijkstra**ï¼š
- ä½¿ç”¨ `if (vis[u]) continue;` è‡ªåŠ¨å¤„ç†

**SPFA/Bellman-Ford**ï¼š
- è‡ªåŠ¨å¤„ç†ï¼ˆä¼šé€‰æ‹©æœ€çŸ­çš„è¾¹ï¼‰

---

## ğŸ“ å®Œæ•´ä½¿ç”¨æ¨¡æ¿

### åœºæ™¯1ï¼šåªæœ‰éè´Ÿæƒè¾¹

```cpp
// ä½¿ç”¨Dijkstraï¼ˆæœ€å¿«ï¼‰
vector<int> dist = dijkstra(start, n);
```

### åœºæ™¯2ï¼šå­˜åœ¨è´Ÿæƒè¾¹

```cpp
// ä½¿ç”¨SPFAï¼ˆæ¨èï¼‰
vector<int> dist;
bool success = spfa(start, n, dist);
if (!success) {
    cout << "å­˜åœ¨è´Ÿç¯ï¼" << endl;
}
```

### åœºæ™¯3ï¼šéœ€è¦æ£€æµ‹è´Ÿç¯

```cpp
// ä½¿ç”¨SPFAæˆ–Bellman-Ford
vector<int> dist;
bool success = spfa(start, n, dist);
if (!success) {
    // å¤„ç†è´Ÿç¯æƒ…å†µ
}
```

### åœºæ™¯4ï¼šéœ€è¦è·¯å¾„è®°å½•

```cpp
vector<int> dist, parent;
bool success = spfaWithPath(start, n, dist, parent);

// æ‰“å°è·¯å¾„
void printPath(int start, int end, const vector<int>& parent) {
    vector<int> path;
    int curr = end;
    while (curr != -1) {
        path.push_back(curr);
        curr = parent[curr];
    }
    reverse(path.begin(), path.end());
    // è¾“å‡ºè·¯å¾„
}
```

---

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **INFå€¼**ï¼šä½¿ç”¨ `INT_MAX` æˆ–è¶³å¤Ÿå¤§çš„å€¼
2. **æ•°ç»„å¤§å°**ï¼šæ ¹æ®é¢˜ç›®è¦æ±‚è®¾ç½® `MAXN`
3. **è´Ÿç¯æ£€æµ‹**ï¼šSPFAä¸­ `cnt[v] > n` è¡¨ç¤ºå­˜åœ¨è´Ÿç¯
4. **è‡ªç¯å¤„ç†**ï¼šæ­£æƒè‡ªç¯ä¸å½±å“ï¼Œè´Ÿæƒè‡ªç¯ä¼šå¯¼è‡´è´Ÿç¯
5. **é‡è¾¹å¤„ç†**ï¼šç®—æ³•ä¼šè‡ªåŠ¨é€‰æ‹©æœ€çŸ­çš„è¾¹

---

## ğŸ”— ç›¸å…³é¢˜ç›®

- **20C - Dijkstra?**ï¼šDijkstraç®—æ³•ï¼Œéœ€è¦è¾“å‡ºè·¯å¾„
- **59E - Shortest Path**ï¼šå¸¦é™åˆ¶çš„æœ€çŸ­è·¯å¾„
- **1915F - Greetings**ï¼šæœ€çŸ­è·¯å¾„å˜ç§

---

## ğŸ’¡ é€‰æ‹©å»ºè®®

1. **åªæœ‰éè´Ÿæƒè¾¹** â†’ ä½¿ç”¨ **Dijkstra**ï¼ˆæœ€å¿«ï¼‰
2. **å­˜åœ¨è´Ÿæƒè¾¹** â†’ ä½¿ç”¨ **SPFA**ï¼ˆæ¨èï¼‰
3. **éœ€è¦æ£€æµ‹è´Ÿç¯** â†’ ä½¿ç”¨ **SPFA** æˆ– **Bellman-Ford**
4. **ç¨ å¯†å›¾** â†’ è€ƒè™‘ **Bellman-Ford**
5. **ç¨€ç–å›¾** â†’ ä½¿ç”¨ **SPFA**












