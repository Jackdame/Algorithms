# <center>æ¯”èµ›èµ„æ–™

### *<center>Edited by chaoweic*
<!-- pagebreak -->


### é¢„å¤„ç†ç‰‡æ®µ
```c
#include <bits/stdc++.h>
#define fi first
#define se second
#define all(a) a.begin(),a.end()
#define rall(a) a.rbegin(),a.rend()
#define req(i,a,n) for(int i = a; i <= n; ++i)
#define rep(i,a,n) for(int i = a; i >= n; --i)
#define pb push_back
#define int long long
using namespace std;
using LL = long long;
typedef pair<int,int> PII;
typedef pair<long long,long long> PLL;
const int INF = 0x3f3f3f3f;
const LL mod = 1e9 + 7;
const int N = 1e5;
void Solve()
{}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    Solve();
    return 0;
}

```
## åŸºç¡€ç®—æ³•

### æ’åº
```c
void quick_sort(int q[], int l, int r)
{
    //é€’å½’çš„ç»ˆæ­¢æƒ…å†µ
    if (l >= r) return;
    //é€‰å–åˆ†ç•Œçº¿ã€‚è¿™é‡Œé€‰æ•°ç»„ä¸­é—´é‚£ä¸ªæ•°
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    //åˆ’åˆ†æˆå·¦å³ä¸¤ä¸ªéƒ¨åˆ†
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    //å¯¹å·¦å³éƒ¨åˆ†æ’åº
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}  
void merge_sort(int q[], int l, int r)
{
    //é€’å½’çš„ç»ˆæ­¢æƒ…å†µ
    if (l >= r) return;
    //ç¬¬ä¸€æ­¥ï¼šåˆ†æˆå­é—®é¢˜
    int mid = l + r >> 1;
    //ç¬¬äºŒæ­¥ï¼šé€’å½’å¤„ç†å­é—®é¢˜(å¯ä»¥æ±‚é€†åºå¯¹)
    LL res = merge_sort(q, l, mid) + merge_sort(q, mid + 1, r);
    //ç¬¬ä¸‰æ­¥ï¼šåˆå¹¶å­é—®é¢˜
    int k = 0, i = l, j = mid + 1; 
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else res += mid - i + 1; tmp[k ++ ] = q[j ++ ];
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];
    //ç¬¬å››æ­¥ï¼šå¤åˆ¶å›åŸæ•°ç»„
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```

### äºŒåˆ†
```c
//ç¬¬ä¸€ä¸ªå¤§äºç­‰äºxçš„æ•°
int bsearch(int l,int r)
{
    int x;
    cin >> x;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (q[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return l;
}
//æ‰¾æœ€åä¸€ä¸ªå°äºç­‰äºxçš„æ•°
int bsearch(int l,int r)
{
    int x;
    cin >> x;
    while (l < r)
    {
        int mid = l + r +1  >> 1;
        if (q[mid] <= x) l = mid;
        else r = mid - 1;
    }
    return l;
}
//æµ®ç‚¹äºŒåˆ†
while(r-l>1e5) 
{
    double mid = (l+r)/2;//æ³¨æ„ä¸èƒ½ç”¨ç§»ä½
    if(check(mid)) l=mid; 
    else r=mid; 
}
double y;//è§£æ–¹ç¨‹
cin>>y;
double l = 0,r = 100;
for(int i=0;i<50;i++)
{
    double m = (l + r)/2;
    if(2018*m*m*m*m+21*m+5*m*m*m+5*m*m+14 >= y) r = m;
    else l = m;
}
if(l==0||r==100) cout<<-1<<endl;
else cout<<fixed<<setprecision(4)<<r<<endl;
//è“æ¡¥æ¯åˆ†å·§å…‹åŠ›
bool check(int l) //åˆ¤æ–­ä¸€å…±èƒ½å¦åˆ†kå—è¾¹é•¿ä¸ºlçš„å·§å…‹åŠ›
{
	int s = 0;
	for (int i = 1; i <= n; i++) s += (a[i] / l) * (b[i] / l);
	if (s >= k) return true;
	return false;
}
int main()
{
	cin >> n >> k;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i] >> b[i];
		m = max(max(a[i], b[i]), m);//æœ€å¤§è¾¹é•¿
	}
	int mid, l = 0, r = m + 1;//äºŒåˆ†æŸ¥æ‰¾ åˆå§‹åŒ–è¾¹é•¿åŒºé—´
	while (l + 1 < r)
	{
		mid = (l + r )/2;
		if (check(mid)) l = mid;//å°è¯•æ›´é•¿è¾¹é•¿
		else r = mid;//æ›´å°è¾¹é•¿
	}
	if (check(l)) cout << l << endl;
	else cout << r << endl;
}
```

### é«˜ç²¾åº¦
```c
vector<int> add(vector<int> &A, vector<int> &B) //åŠ æ³•
{
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    req(i,0,A.size() - 1)
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
    if (t) C.push_back(t);
    return C;
}
void mutiply() //ä¹˜æ³•
{
    char a1[10001], b1[10001];
    int a[10001], b[10001], i, x, len, j, c[10001];
    int lena = strlen(a1); 
    int lenb = strlen(b1); 
    req(i,1,lena)
        a[i] = a1[lena - i] - '0';
    req(i,1,lenb)
        b[i] = b1[lenb - i] - '0';
    req(i,1,lenb)
        req(j,1,lena)
            c[i + j - 1] += a[j] * b[i];
    req(i,1,lena + lenb - 1)
        if (c[i] > 9)
        {
            c[i + 1] += c[i] / 10;
            c[i] %= 10;
        }
    len = lena + lenb;
    while (c[len] == 0 && len > 1)
        len--;
    rep(i,len,1)
        cout << c[i];
}
```

### å‰ç¼€å’Œä¸å·®åˆ†
```c
for (int i = 1; i <= n; i ++ ) s[i] = s[i - 1] + q[i]; //ä¸€ç»´å‰ç¼€å’Œ
s[r]-s[l-1];//ä¸‹æ ‡l-1åˆ°ræ‰€æœ‰æ•°çš„å’Œï¼Œæœ¬è´¨é¢„å¤„ç†æ“ä½œ
s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];//æ„é€ äºŒç»´å‰ç¼€å’Œ 
s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1] //æŸ¥è¯¢æ“ä½œ
b[i] = a[i] - a[i - 1];      //æ„å»ºå·®åˆ†æ•°ç»„
b[l] += c; b[r + 1] -= c;//åŸæ•°ç»„låˆ°rå…¨éƒ¨åŠ c
b[i] += b[i - 1];  //å¤åŸåŸæ•°ç»„
void insert(int x1, int y1, int x2, int y2, int c) //äºŒç»´å·®åˆ†
{
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}
req(i,1,n)
        req(j,1,m)
            insert(i, j, i, j, a[i][j]); //åˆå§‹åŒ–å·®åˆ†æ•°ç»„b
insert(x1, y1, x2, y2, c); //åŸæ•°ç»„å±€éƒ¨çŸ©é˜µå…¨éƒ¨åŠ c
b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];//å¤åŸ
//çº¿æ®µè¦†ç›–
vector<int> a(n),b(n),c(n);
req(i,0,n-1)
    cin >> a[i];
req(i,1,n-1)
   b[i] = a[i] - a[i - 1];
sort(b.begin(), b.end());
req(i, 1, n - 1)
    c[i] = c[i-1] + b[i];
for (int i = n-1; i >= 0;i--)
    cout << c[i] << " ";
```

### åŒæŒ‡é’ˆ
```c
int res = 0; //æœ€é•¿ä¸é‡å¤å­åºåˆ—çš„é•¿åº¦
for (int i = 0, j = 0; i < n; i ++ )
{
    s[q[i]] ++ ;//qæ˜¯åŸæ•°ç»„ sç”¨æ¥è®°å½•åŒºé—´å†…å…ƒç´ çš„æ•°é‡
    while (j < i && s[q[i]] > 1) s[q[j ++ ]] -- ;
    res = max(res, i - j + 1);
}
for (int i = 0, j = m - 1; i < n; i ++ )//æ•°ç»„å…ƒç´ çš„ç›®æ ‡å’Œ
{
    while (j >= 0 && a[i] + b[j] > x) j -- ;
    if (j >= 0 && a[i] + b[j] == x) cout << i << ' ' << j << endl;
}
int i = 0, j = 0;//åˆ¤æ–­å­åºåˆ—
while (i < n && j < m)
{
    if (a[i] == b[j]) i ++ ;
    j ++ ;
}
```

### ç¦»æ•£åŒ–
```c
vector<int> alls;//å­˜å…¥ä¸‹æ ‡å®¹å™¨
vector<PII> add, query;//addå¢åŠ å®¹å™¨ï¼Œå­˜å…¥å¯¹åº”ä¸‹æ ‡å’Œå¢åŠ çš„å€¼çš„å¤§å°
//queryå­˜å…¥éœ€è¦è®¡ç®—ä¸‹æ ‡åŒºé—´å’Œçš„å®¹å™¨
int find(int x)
{
    int l = 0, r = alls.size() - 1;
    while (l < r)//æŸ¥æ‰¾å¤§äºç­‰äºxçš„æœ€å°çš„å€¼çš„ä¸‹æ ‡
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;//å› ä¸ºä½¿ç”¨å‰ç¼€å’Œï¼Œå…¶ä¸‹æ ‡è¦+1å¯ä»¥ä¸è€ƒè™‘è¾¹ç•Œé—®é¢˜
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i ++ )
    {
        int x, c;
        cin >> x >> c;
        add.push_back({x, c});//å­˜å…¥ä¸‹æ ‡å³å¯¹åº”çš„æ•°å€¼c

        alls.push_back(x);//å­˜å…¥æ•°ç»„ä¸‹æ ‡x=add.first
    }

    for (int i = 0; i < m; i ++ )
    {
        int l, r;
        cin >> l >> r;
        query.push_back({l, r});//å­˜å…¥è¦æ±‚çš„åŒºé—´

        alls.push_back(l);//å­˜å…¥åŒºé—´å·¦å³ä¸‹æ ‡
        alls.push_back(r);
    }

    // åŒºé—´å»é‡
    sort(alls.begin(), alls.end());
    alls.erase(unique(alls.begin(), alls.end()), alls.end());

    // å¤„ç†æ’å…¥
    for (auto item : add)
    {
        int x = find(item.first);//å°†addå®¹å™¨çš„add.secendå€¼å­˜å…¥æ•°ç»„a[]å½“ä¸­ï¼Œ
        a[x] += item.second;//åœ¨å»é‡ä¹‹åçš„ä¸‹æ ‡é›†åˆallså†…å¯»æ‰¾å¯¹åº”çš„ä¸‹æ ‡å¹¶æ·»åŠ æ•°å€¼
    }

    // é¢„å¤„ç†å‰ç¼€å’Œ
    for (int i = 1; i <= alls.size(); i ++ ) s[i] = s[i - 1] + a[i];

    // å¤„ç†è¯¢é—®
    for (auto item : query)
    {
        int l = find(item.first), r = find(item.second);
        cout << s[r] - s[l - 1] << endl;
    }
}
//åœ¨ä¸‹æ ‡å®¹å™¨ä¸­æŸ¥æ‰¾å¯¹åº”çš„å·¦å³ä¸¤ç«¯[l~r]ä¸‹æ ‡ï¼Œç„¶åé€šè¿‡ä¸‹æ ‡å¾—åˆ°å‰ç¼€å’Œç›¸å‡å†å¾—åˆ°åŒºé—´a[l~r]çš„å’Œ
```

### åŒºé—´åˆå¹¶
```c
vector<pair<int, int>> intervals, result;
static bool cmp(pair<int, int> &a, pair<int, int> &b) {
    return a.first < b.first;
}
int main () {
    cin >> n;
    for (int i = 0; i < n; i++) {
        int l, r;
        cin >> l >> r;
        intervals.push_back ({l, r});
    }
    sort(intervals.begin(), intervals.end(), cmp);

    result.push_back(intervals[0]);  // å°†ç¬¬ä¸€ä¸ªåŒºé—´åŠ å…¥

    for (int i = 1; i < intervals.size(); i++) {
        if (result.back().second >= intervals[i].first) {
            result.back().second = max(result.back().second, intervals[i].second); 
        } else {
            result.push_back (intervals[i]);
        }
    }
    cout << result.size() << endl;//åˆå¹¶ååŒºé—´ä¸ªæ•°
}
```

## æ•°æ®ç»“æ„

### é“¾è¡¨
```c 
// head è¡¨ç¤ºå¤´ç»“ç‚¹çš„ä¸‹æ ‡ e[i] è¡¨ç¤ºèŠ‚ç‚¹içš„å€¼ ne[i] è¡¨ç¤ºèŠ‚ç‚¹içš„nextæŒ‡é’ˆæ˜¯å¤šå°‘ 
// idx å­˜å‚¨å½“å‰å·²ç»ç”¨åˆ°äº†å“ªä¸ªç‚¹ é‡‡ç”¨æ•°ç»„æ¨¡æ‹Ÿé“¾è¡¨
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void add_to_head(int x) // å°†xæ’åˆ°å¤´ç»“ç‚¹
{
    e[idx] = x, ne[idx] = head, head = idx ++ ;
}
void add(int k, int x) // å°†xæ’åˆ°ä¸‹æ ‡æ˜¯kçš„ç‚¹åé¢
{
    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++ ;
}
void remove(int k) // å°†ä¸‹æ ‡æ˜¯kçš„ç‚¹åé¢çš„ç‚¹åˆ æ‰
{
    ne[k] = ne[ne[k]];
}
```

### æ ˆ
```c
stack<type> a; .push(x) .pop() //ç§»é™¤æ ˆé¡¶å…ƒç´ 
.top() .empty() .size()
```

### é˜Ÿåˆ—
```c
queue<type> q; .front() .back()
.push() .pop()
.size() .empty()
deque<type> dq;//åŒç«¯é˜Ÿåˆ— å¯ä»¥åŒå‘è¿›å‡º
.pop_back() .pop_front() //pushåŒç† 
```

### å †
```c
priority_queue<type,vector<type>,greater<type>> pq; .top()//é»˜è®¤å¤§æ ¹å †
.push(x) .pop() // é˜Ÿé¡¶å…ƒç´ å‡ºé˜Ÿ
.size() .empty()
```

### å¹¶æŸ¥é›†
```c
struct DSU {
    vector<int> p, r;
    DSU(int n=0){init(n);}
    void init(int n){ p.resize(n); iota(p.begin(),p.end(),0); r.assign(n,0); }
    int find(int x){ return p[x]==x?x:p[x]=find(p[x]); }
    bool unite(int a,int b){
        a=find(a); b=find(b);
        if(a==b) return false;
        if(r[a]<r[b]) swap(a,b);
        p[b]=a;
        if(r[a]==r[b]) r[a]++;
        return true;
    }
};
```

### æ ‘çŠ¶æ•°ç»„
```c
struct BIT {
    int n; vector<LL> t;
    BIT(int _n=0){init(_n);}
    void init(int _n){ n=_n; t.assign(n+1,0); }
    void add(int i, ll v){ for(; i<=n; i+=i&-i) t[i]+=v; }
    LL sum(int i){ ll s=0; for(; i>0; i-=i&-i) s+=t[i]; return s; }
    LL sum(int l, int r){ return sum(r)-sum(l-1); }
};
```

### çº¿æ®µæ ‘
```c
struct Seg {
    int n; struct Node{ ll sum, add; } ;
    vector<Node> t;
    Seg(int _n=0){init(_n);}
    void init(int _n){ n=_n; t.assign(4*n+4,{0,0}); }
    void pull(int o){ t[o].sum = t[o<<1].sum + t[o<<1|1].sum; }
    void apply(int o, int l, int r, ll v){
        t[o].sum += v * (r-l+1);
        t[o].add += v;
    }
    void push(int o, int l, int r){
        if(t[o].add!=0){
            int m=(l+r)>>1;
            apply(o<<1, l, m, t[o].add);
            apply(o<<1|1, m+1, r, t[o].add);
            t[o].add=0;
        }
    }
    void add(int o,int l,int r,int L,int R,ll v){
        if(L>r||R<l) return;
        if(L<=l&&r<=R){ apply(o,l,r,v); return; }
        push(o,l,r);
        int m=(l+r)>>1;
        add(o<<1,l,m,L,R,v); add(o<<1|1,m+1,r,L,R,v);
        pull(o);
    }
    ll query(int o,int l,int r,int L,int R){
        if(L>r||R<l) return 0;
        if(L<=l&&r<=R) return t[o].sum;
        push(o,l,r);
        int m=(l+r)>>1;
        return query(o<<1,l,m,L,R)+query(o<<1|1,m+1,r,L,R);
    }
    // wrapper: add(1,1,n,L,R,v), query(1,1,n,L,R)
};
```

### å•è°ƒé˜Ÿåˆ—
```c
vector<int> slide_max(const vector<int>& a, int k){
    deque<int> dq; vector<int> res;
    req(i,0,a.size()-1)
    {
        while(!dq.empty() && a[dq.back()]<=a[i]) dq.pop_back();
        dq.push_back(i);
        if(dq.front() <= i-k) dq.pop_front();
        if(i>=k-1) res.push_back(a[dq.front()]);
    }
    return res; //æ»‘åŠ¨çª—å£max/min
}
```

### Trie
```c
struct BinTrie //äºŒè¿›åˆ¶å­—å…¸æ ‘
{
    struct Node{ int ch[2]; Node(){ch[0]=ch[1]=-1;} };
    vector<Node> t;
    BinTrie(){ t.push_back(Node()); }
    void insert(int x, int B=30){
        int u=0;
        rep(i,B,0)
        {
            int b=(x>>i)&1;
            if(t[u].ch[b]==-1){ t[u].ch[b]=t.size(); t.push_back(Node()); }
            u=t[u].ch[b];
        }
    }
    int max_xor(int x, int B=30){
        int u=0, ans=0;
        rep(i,B,0)
        {
            int b=(x>>i)&1;
            int want = b^1;
            if(t[u].ch[want]!=-1){ ans |= (1<<i); u=t[u].ch[want]; }
            else u = t[u].ch[b];
        }
        return ans;
    }
};
```
### å“ˆå¸Œè¡¨
```c
struct FastHash {
    size_t operator()(uint64_t x) const {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }
};
// unordered_map<long long, int, FastHash> mp;
//mapå’Œunordered_mapçš„åŒºåˆ«: å‰è€…éå†æ’åºæ—¶æŒ‰å­—å…¸åºå‡åºæ’, åè€…æ— åºã€‚å¹¶ä¸”å‰è€…O(logn)åè€…ç†æƒ³æƒ…å†µä¸‹O(1)
unordered_set<type> ut;//æ— åºé›†åˆ
.size() .empty() .find() .count()//å‡ºç°æ¬¡æ•°
insert() erase() 
```

### STè¡¨
```c
template<typename T, typename F>
struct SparseTable {
    int n, LG;
    vector<vector<T>> st;
    vector<int> lg;
    F combine;
    SparseTable() {}
    SparseTable(const vector<T>& a, F f): combine(f) { build(a); }
    void build(const vector<T>& a){
        n = a.size();
        if(n==0) return;
        LG = 32 - __builtin_clz(n);
        st.assign(LG, vector<T>(n));
        lg.assign(n+1,0);
        for(int i=2;i<=n;i++) lg[i] = lg[i>>1] + 1;
        st[0] = a;
        for(int k=1;k<LG;k++){
            int len = 1<<k;
            for(int i=0;i+len-1<n;i++){
                st[k][i] = combine(st[k-1][i], st[k-1][i + (1<<(k-1))]);
            }
        }
    }
    T query(int l,int r){
        int k = lg[r-l+1];
        return combine(st[k][l], st[k][r-(1<<k)+1]);
    }
};
// min
SparseTable<int, function<int(int,int)>> st(a, [](int x,int y){ return min(x,y); });
// max
SparseTable<int, function<int(int,int)>> st2(a, [](int x,int y){ return max(x,y); });
// gcd (éœ€è¦ include <numeric>)
SparseTable<int, function<int(int,int)>> stg(a, [](int x,int y){ return std::gcd(x,y); });

```

## æœç´¢ä¸å›¾è®º

### DFS
```c
//é€’å½’å½¢å¼
vector<vector<int>> g;
vector<char> vis;
void dfs(int u){
    vis[u] = 1;
    // process u
    for(int v: g[u]){
        if(!vis[v]) dfs(v);
    }
}
//éé€’å½’å½¢å¼
vector<int> st;
st.push_back(start);
vis[start]=1;
while(!st.empty()){
    int u = st.back(); st.pop_back();
    // process u
    for(int v: g[u]){
        if(!vis[v]){
            vis[v]=1;
            st.push_back(v);
        }
    }
}
//å…«çš‡å
int print()
{
    if(tol<=2)
    {
        req(k,1,n)
        {
            cout << a[k] << " ";
            cout << endl;
        }
    }
    tol++;
}
void dfs(int i)
{
    if(i>n)
    {
        print();
        return;
    }
    else
    {
        req(j,1,n)
        {
            if((!b[j])&&(!c[i+j])&&(!d[i-j+n]))
            {
                a[i] = j;b[j] = 1;c[i + j] = 1;d[i - j + n] = 1;
                dfs(i + 1);
                b[j] = 0;c[i + j] = 0;d[i - j + n] = 0;//å›æº¯
            }
        }
    }
}
//å›æº¯/ç»„åˆ/å…¨æ’åˆ—(å¸¦å‰ªæ)
vector<int> sol;
vector<char> used(n,false);
void backtrack(int pos){
    if(pos == target_len){
        // handle sol
        return;
    }
    for(int i=0;i<n;i++){
        if(used[i]) continue; // å‰ªæç¤ºä¾‹ï¼šå¦‚æœæ”¾ i å¯¼è‡´ä¸å¯èƒ½è¾¾åˆ°æœ€ä¼˜ï¼Œcontinue;
        used[i]=1; sol.push_back(i);
        backtrack(pos+1);
        sol.pop_back(); used[i]=0;
    }
}

```

### BFS
```c
//æ— æƒæœ€çŸ­è·¯
vector<int> dist(n, -1), par(n, -1);
queue<int> q;
dist[s]=0; q.push(s);
while(!q.empty()){
    int u=q.front(); q.pop();
    for(int v: g[u]){
        if(dist[v]==-1){
            dist[v]=dist[u]+1;
            par[v]=u;
            q.push(v);
        }
    }
}
//è¿·å®«æœ€çŸ­è·¯
queue<PII> q;
    memset(d, -1, sizeof d);
    d[0][m-1] = 0;
    q.push({0, m-1});
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
    while (q.size())
    {
        auto t = q.front();
        q.pop();
        for (int i = 0; i < 4; i++)
        {
            int x = t.first + dx[i], y = t.second + dy[i];
            if (x >= 0 && x < n + 2 && y >= 0 && y < m && p[x][y] && d[x][y] == -1)
            {
                d[x][y] = d[t.first][t.second] + 1;
                q.push({x, y});
                if(x == n+1 && y == 0)
                {
                    return d[x][y];
                }
            }
        }
    }
    queue<int> qa, qb;

//åŒå‘bfs
vector<int> da(n,-1), db(n,-1);
qa.push(sa); da[sa]=0;
qb.push(sb); db[sb]=0;
int ans = -1;
while(!qa.empty() && !qb.empty()){
    // expand one side (choose smaller frontier)
    if(qa.size() <= qb.size()){
        int u=qa.front(); qa.pop();
        for(int v: g[u]){
            if(da[v]==-1){ da[v]=da[u]+1; qa.push(v); 
            if(db[v]!=-1){ ans = da[v]+db[v]; break; } }
        }
    } else {
        int u=qb.front(); qb.pop();
        for(int v: g[u]){
            if(db[v]==-1){ db[v]=db[u]+1; qb.push(v); 
            if(da[v]!=-1){ ans = da[v]+db[v]; break; } }
        }
    }
    if(ans!=-1) break;
}
```

### è®°å¿†åŒ–æœç´¢
```c
//æ»‘é›ª
int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};
int n, m, a[201][201], s[201][201], ans;
bool use[201][201]; // è¿™ä¸ªå°±æ˜¯æ‰€è°“çš„ä¸éœ€è¦
int dfs(int x, int y)
{
    if (s[x][y])
        return s[x][y]; // è®°å¿†åŒ–æœç´¢
    s[x][y] = 1;        // é¢˜ç›®ä¸­ç­”æ¡ˆæ˜¯æœ‰åŒ…å«è¿™ä¸ªç‚¹çš„
    for (int i = 0; i < 4; i++)
    {
        int xx = dx[i] + x;
        int yy = dy[i] + y; // å››ä¸ªæ–¹å‘
        if (xx > 0 && yy > 0 && xx <= n && yy <= m && a[x][y] > a[xx][yy])
        {
            dfs(xx, yy);
            s[x][y] = max(s[x][y], s[xx][yy] + 1);
        }
    }
    return s[x][y];
}
```
### Dijkstra

```c
//å¸¦è·¯å¾„å›æº¯æ±‚æœ€çŸ­è·¯
struct Edge //å›¾ç»“æ„
{
    int to;
    LL weight;
    Edge(int t, LL w) : to(t), weight(w) {}
};
vector<vector<Edge>> g(N);
vector<LL> dj(int start, int n, vector<int> &parent)
{
    vector<LL> dist(n + 1, INF);
    vector<bool> vis(n + 1, false);
    parent.assign(n + 1, -1);
    priority_queue<PII, vector<PII>, greater<PII>> pq;
    dist[start] = 0;
    pq.push({0, start});
    while (!pq.empty())
    {
        int u = pq.top().second;
        LL d = pq.top().first;
        pq.pop();
        if (vis[u])
            continue;
        vis[u] = true;
        for (const Edge &e : g[u])
        {
            int v = e.to;
            LL w = e.weight;
            if (dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                parent[v] = u;
                pq.push({dist[v], v});
            }
        }
    }
    return dist;
}
void print(int start, int end, const vector<int> &parent) //æ‰“å°è·¯å¾„
{
    if (parent[end] == -1 && end != start)
    {
        cout << -1 << endl;
        return;
    }
    vector<int> path;
    int cur = end;
    while (cur != -1)
    {
        path.push_back(cur);
        cur = parent[cur];
    }
    reverse(path.begin(), path.end());
    for (int i = 0; i < path.size(); i++)
    {
        cout << path[i];
        if (i < path.size() - 1)
            cout << " ";
    }
    cout << endl;
}
void add(int u, int v, int w) //å»ºå›¾
{
    g[u].push_back(Edge(v, w));
    g[v].push_back(Edge(u, w));
}
void Solve()
{
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int u, v, w;
        cin >> u >> v >> w;
        add(u, v, w);
    }
    vector<int> parent;
    vector<LL> dist = dj(1, n, parent);
    if (dist[n] == INF)
    {
        cout << -1 << endl;
    }
    else
        print(1, n, parent);
}
```

### SPFA
```c
int spfa() //å¯ä»¥åŒ…å«è´Ÿæƒè¾¹æ±‚æœ€çŸ­è·¯
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        int t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return dist[n];
}
bool spfa() //åˆ¤æ–­æ˜¯å¦å­˜åœ¨è´Ÿç¯
{
    queue<int> q;

    for (int i = 1; i <= n; i ++ )
    {
        st[i] = true;
        q.push(i);
    }

    while (q.size())
    {
        int t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;

                if (cnt[j] >= n) return true;
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    return false;
}
```

### æœ€å°ç”Ÿæˆæ ‘
```c
struct Edge {
    int u, v, w;
    bool operator<(const Edge& other) const {
        return w < other.w;
    }
};

vector<Edge> edges;
int parent[N];

int find(int x) {
    if (parent[x] != x) parent[x] = find(parent[x]);
    return parent[x];
}

int kruskal(int n) {
    sort(edges.begin(), edges.end());
    for (int i = 1; i <= n; i++) parent[i] = i;
    int total_weight = 0, cnt = 0;
    for (const auto& e : edges) {
        int pu = find(e.u), pv = find(e.v);
        if (pu != pv) {
            parent[pu] = pv;
            total_weight += e.w;
            cnt++;
            if (cnt == n - 1) break;
        }
    }
    return total_weight;
}
```
## åŠ¨æ€è§„åˆ’

* ä¸»è¦æ€è·¯ï¼š
1.çŠ¶æ€è¡¨ç¤ºf[i][j];
2.çŠ¶æ€è½¬ç§»æ–¹ç¨‹(é›†åˆåˆ’åˆ†)
### èƒŒåŒ…é—®é¢˜
```c
req(i,1,n)
{
    rep(j,m,v[i])
    {
        f[j] = max(f[j], f[j - v[i]]+w[i]);//01èƒŒåŒ…
    }
}
req(i,1,n)
{
    req(j,0,m)
    {
        for (int k = 0; k <= s[i] && k * v[i] <= j;k++) //å¤šé‡èƒŒåŒ…
    }
}
req(i,1,n)
{
    rep(j,m,0)
    {
        req(k,0,s[i]-1)
        {
            if(v[i][k]<=j)
                f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); //åˆ†ç»„èƒŒåŒ…
        }
    }
}
req(i,1,n)
{
    req(j,v[i],m)
    {
        f[j] = max(f[j], f[j - v[i]] + w[i]); //å®Œå…¨èƒŒåŒ…
    }
}
```

### çº¿æ€§dp

```c
//æ•°å­—ä¸‰è§’å½¢
f[1][1] = a[1][1];
req(i,2,n)
{
    req(j,1,i)
    {
        f[i][j] = max(f[i - 1][j - 1] + a[i][j], f[i - 1][j] + a[i][j]);
    }
}
int res = -INF;
req(i,1,n)
{
    res = max(res, f[n][i]);
}
//æœ€é•¿ä¸Šå‡å­åºåˆ—
req(i,1,n) 
{
    f[i] = 1;
    req(j,1,i-1)
    {
        if(a[j]<a[i])
        {
            f[i] = max(f[i], f[j] + 1);
        }
    }
}
int res = 0;
req(i, 1, n){
    res = max(res, f[i]);
}
//æœ€é•¿å…¬å…±å­åºåˆ—
req(i,1,n)
{
    req(j,1,m)
    {
        f[i][j] = max(f[i - 1][j], f[i][j - 1]);
        if(a[i] == b[j])
            f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
    }
}
//æœ€çŸ­ç¼–è¾‘è·ç¦»
req(i,0,m)
    f[0][i] = i;
req(i,0,n)
    f[i][0] = i;
req(i,1,n)
{
    req(j,1,m)
    {
        f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1);
        if(a[i] == b[j])
            f[i][j] = min(f[i][j], f[i - 1][j - 1]);
        else
            f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1);
    }
}
```

### åŒºé—´dp
```c
//çŸ³å­åˆå¹¶æœ€å°ä»£ä»·
for (int i = 1; i <= n; i++)
    s[i] += s[i - 1];
for (int len = 2; len <= n; len++) {
    for (int i = 1; i + len - 1 <= n; i++)
    {
        int l = i, r = i + len - 1;
        f[l][r] = 1e8;
        for (int k = l; k < r; k++)
            f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);
    }
    printf("%d\n", f[1][n]);
}
```

### å…¶ä»–dpæ¨¡å‹
```c
// çŠ¶æ€æœºDP
int dp[N][2]; // 0/1è¡¨ç¤ºçŠ¶æ€
dp[i][0] = max(dp[i-1][0], dp[i-1][1]);
dp[i][1] = dp[i-1][0] + w[i];

// æ ‘å½¢DPæ¨¡æ¿
void dfs(int u, int fa) {
    dp[u][0] = 0; // ä¸é€‰u
    dp[u][1] = w[u]; // é€‰u
    for(int v : g[u]) {
        if(v == fa) continue;
        dfs(v, u);
        dp[u][0] += max(dp[v][0], dp[v][1]);
        dp[u][1] += dp[v][0];
    }
}

// çŠ¶å‹DP
for(int mask = 0; mask < (1<<n); mask++) {
    for(int i = 0; i < n; i++) {
        if(mask >> i & 1) {
            int pre = mask ^ (1 << i);
            dp[mask] = max(dp[mask], dp[pre] + ...);
        }
    }
}
```
## æ•°å­¦ç†è®º

### æ•°è®º
```c
//æ¬§æ‹‰ç­›
int primes[N], cnt;     // primes[]å­˜å‚¨æ‰€æœ‰ç´ æ•°
bool st[N];         // st[x]å­˜å‚¨xæ˜¯å¦è¢«ç­›æ‰
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
//æ±‚xçº¦æ•°ä¸ªæ•°
int x;cin >> x;
for (int i = 2; i <= x / i; i ++ ) {
    while (x % i == 0)
    {
        x /= i;
        primes[i] ++ ;
    }

    if (x > 1) primes[x] ++ ;
}
//æ±‚nä¸ªæ•°ä¹˜ç§¯çš„çº¦æ•°ä¹‹å’Œ (è‡ªç„¶æ•°åˆ†è§£åŸç†)
unordered_map<int, int> primes;
while (n -- )
{
    int x;
    cin >> x;
    for (int i = 2; i <= x / i; i ++ )
        while (x % i == 0)
        {
            x /= i;
            primes[i] ++ ;
        }
    if (x > 1) primes[x] ++ ;
}
LL res = 1;
for (auto p : primes)
{
    LL a = p.first, b = p.second;
    LL t = 1;
    while (b -- ) t = (t * a + 1) % mod;
    res = res * t % mod;
}
//æœ€å¤§å…¬çº¦æ•°
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```

### å¿«é€Ÿå¹‚
```c
//è¿”å›pow(a,b) mod p
LL qm(int a, int b, int p)
{
    LL res = 1 % p;
    while (b)
    {
        if (b & 1) res = res * a % p;
        a = a * (LL)a % p;
        b >>= 1;
    }
    return res;
}
```

### æ’åˆ—ç»„åˆ
```c
//æ±‚ç»„åˆæ•° n<=2000
void init()
{
    req(i,0,N-1)
        req(j,0,i)
            if (!j) c[i][j] = 1;
            else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;//é¢„å¤„ç†ç»„åˆæ•°æ•°ç»„
}
//å®¹æ–¥åŸç†
//å­—ç¬¦ä¸²ç¼©å†™å¤ªå¤šäº†
long long mod = 1000000007, n, ans = 0, k, i;
cin >> n;
req(i,0,n-1)
    scanf("%s", s);
k = 1;
req(i,n,1)
{
    k = (k * i) % mod;
    ans = (ans + k) % mod;//æ‰€æœ‰ç¼©å†™ä¸ªæ•°
}
```

### ä½è¿ç®—
```c
& | ^ //ä¸æˆ–é
~ //å–å 
```

### åšå¼ˆè®º
å…³äºå…¬å¹³ç»„åˆæ¸¸æˆï¼Œå…¬å¹³ç»„åˆæ¸¸æˆä¸­ï¼Œ
æœ€åŸºç¡€ä¹Ÿæœ€é‡è¦çš„æ˜¯æ­£å¸¸ Nim æ¸¸æˆã€‚Spragueâ€“Grundy å®šç†æŒ‡å‡ºï¼Œæ‰€æœ‰æ­£å¸¸è§„åˆ™çš„å…¬å¹³ç»„åˆæ¸¸æˆéƒ½ç­‰ä»·äºä¸€ä¸ªå•å † Nim æ¸¸æˆã€‚ç”±æ­¤ï¼Œå¯ä»¥å‘å±•å‡º Spragueâ€“Grundy å‡½æ•°å’Œ Nim æ•°çš„æ¦‚å¿µï¼Œå®ƒä»¬å®Œå…¨åœ°åˆ»ç”»äº†ä¸€ä¸ªæ­£å¸¸è§„åˆ™çš„å…¬å¹³ç»„åˆæ¸¸æˆã€‚

åšå¼ˆå›¾ï¼šå°†æ¯ä¸€ä¸ªå¯èƒ½çš„çŠ¶æ€éƒ½çœ‹ä½œæ˜¯å›¾ä¸­çš„ä¸€ä¸ªç»“ç‚¹ï¼Œå¹¶å°†çŠ¶æ€å‘å®ƒçš„åç»§çŠ¶æ€ï¼ˆå³é€šè¿‡ä¸€æ¬¡æ“ä½œå¯ä»¥è¾¾åˆ°çš„çŠ¶æ€ï¼‰è¿è¾¹ï¼Œå°±å¾—åˆ°ä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ï¼Œè¿™å°±æ˜¯åšå¼ˆå›¾ã€‚
```c
//nimæ¸¸æˆï¼šå…±æœ‰ ğ‘›  å †çŸ³å­ï¼Œç¬¬ ğ‘– å †æœ‰ ğ‘ğ‘– æšçŸ³å­ã€‚
//ä¸¤åç©å®¶è½®æµå–èµ°ä»»æ„ä¸€å †ä¸­çš„ä»»æ„å¤šæšçŸ³å­ï¼Œä½†ä¸èƒ½ä¸å–ã€‚å–èµ°æœ€åä¸€æšçŸ³å­çš„ç©å®¶è·èƒœã€‚
req(i,1,n)
{
    cin >> a[i];
    cnt ^= a[i];//nimå’Œ
}
Nim æ¸¸æˆä¸­ï¼ŒçŠ¶æ€ (ğ‘1,ğ‘2,â‹¯,ğ‘ğ‘›)æ˜¯å¿…è´¥æ€å½“ä¸”ä»…å½“nimå’Œä¸º0
```

*å¼•ç†*
1.æ­£å¸¸è§„åˆ™çš„å…¬å¹³ç»„åˆæ¸¸æˆä¸­ï¼Œæ²¡æœ‰åç»§çŠ¶æ€çš„çŠ¶æ€æ˜¯å¿…è´¥çŠ¶æ€ P 
2.ä¸€ä¸ªçŠ¶æ€æ˜¯å¿…èƒœçŠ¶æ€å½“ä¸”ä»…å½“è‡³å°‘ä¸€ä¸ªå®ƒçš„åç»§çŠ¶æ€ä¸ºå¿…è´¥çŠ¶æ€
3.ä¸€ä¸ªçŠ¶æ€æ˜¯å¿…è´¥çŠ¶æ€å½“ä¸”ä»…å½“å®ƒçš„æ‰€æœ‰åç»§çŠ¶æ€å‡ä¸ºå¿…èƒœçŠ¶æ€

SGï¼ˆGrundyï¼‰å‡½æ•°å®šä¹‰ï¼šå¯¹çŠ¶æ€ sï¼Œg(s)=mex{g(t)âˆ£tâˆˆmoves(s)}ï¼Œå…¶ä¸­ mex ä¸ºæœ€å°éè´Ÿæ•´æ•°ä¸åœ¨é›†åˆä¸­ã€‚
Spragueâ€“Grundy å®šç†ï¼šä»»æ„è‹¥å¹²ç‹¬ç«‹å­åšå¼ˆçš„åˆæˆåšå¼ˆçš„ç­‰ä»·ç­¹ç å€¼æ˜¯å„å­åšå¼ˆ SG å€¼çš„å¼‚æˆ–ã€‚åˆæˆåšå¼ˆå…ˆæ‰‹å¿…èƒœå½“ä¸”ä»…å½“â¨igiâ‰ 0ã€‚


## å­—ç¬¦ä¸²

### å­—ç¬¦ä¸²å“ˆå¸Œ
```c
using ULL = unsigned long long;
const ULL base = 131;
ULL h[N], p[N];

void init_hash(const string& s) {
    p[0] = 1;
    for (int i = 1; i <= s.size(); i++) {
        h[i] = h[i-1] * base + s[i-1];
        p[i] = p[i-1] * base;
    }
}

ULL get_hash(int l, int r) {
    return h[r] - h[l-1] * p[r-l+1];
}
```
### KMP
```c
vector<int> Next;
void GetNext(const string& p) {
    int len = p.size();
    Next.resize(len);
    int j = 0, k = -1;
    Next[0] = -1;  
    while (j < len - 1) {
        if (k == -1 || p[k] == p[j]) {
            j++;
            k++;
            Next[j] = k;  
        }
        else {
            k = Next[k];  
        }
    }
}
int KMP(const string& t, const string& p) {
    int n = t.size(), m = p.size();
    if (m == 0) return 0;  
    GetNext(p);           
    int i = 0, j = 0;     
    while (i < n && j < m) {
        if (j == -1 || t[i] == p[j]) {  
            i++;
            j++;
        }
        else {
            j = Next[j];  
        }
    }
    if (j == m) {
        return i - j;    
    }
    else {
        return -1;        
    }
}
```

### ACè‡ªåŠ¨æœº
```c
//ç®€æ˜“ç‰ˆ
struct Tree // å­—å…¸æ ‘
{
    int fail;    // å¤±é…æŒ‡é’ˆ
    int vis[26]; // å­èŠ‚ç‚¹çš„ä½ç½®
    int end;     // æ ‡è®°æœ‰å‡ ä¸ªå•è¯ä»¥è¿™ä¸ªèŠ‚ç‚¹ç»“å°¾
} AC[1000000];   // Trieæ ‘
int cnt = 0;     // Trieçš„æŒ‡é’ˆ
inline void Build(string s)
{
    int l = s.length();
    int now = 0;                // å­—å…¸æ ‘çš„å½“å‰æŒ‡é’ˆ
    for (int i = 0; i < l; ++i) // æ„é€ Trieæ ‘
    {
        if (AC[now].vis[s[i] - 'a'] == 0)    // Trieæ ‘æ²¡æœ‰è¿™ä¸ªå­èŠ‚ç‚¹
            AC[now].vis[s[i] - 'a'] = ++cnt; // æ„é€ å‡ºæ¥
        now = AC[now].vis[s[i] - 'a'];       // å‘ä¸‹æ„é€ 
    }
    AC[now].end += 1; // æ ‡è®°å•è¯ç»“å°¾
}
void Get_fail() // æ„é€ failæŒ‡é’ˆ
{
    queue<int> Q;                // é˜Ÿåˆ—
    for (int i = 0; i < 26; ++i) // ç¬¬äºŒå±‚çš„failæŒ‡é’ˆæå‰å¤„ç†ä¸€ä¸‹
    {
        if (AC[0].vis[i] != 0)
        {
            AC[AC[0].vis[i]].fail = 0; // æŒ‡å‘æ ¹èŠ‚ç‚¹
            Q.push(AC[0].vis[i]);      // å‹å…¥é˜Ÿåˆ—
        }
    }
    while (!Q.empty()) // BFSæ±‚failæŒ‡é’ˆ
    {
        int u = Q.front();
        Q.pop();
        for (int i = 0; i < 26; ++i) // æšä¸¾æ‰€æœ‰å­èŠ‚ç‚¹
        {
            if (AC[u].vis[i] != 0) // å­˜åœ¨è¿™ä¸ªå­èŠ‚ç‚¹
            {
                AC[AC[u].vis[i]].fail = AC[AC[u].fail].vis[i];
                // å­èŠ‚ç‚¹çš„failæŒ‡é’ˆæŒ‡å‘å½“å‰èŠ‚ç‚¹çš„
                // failæŒ‡é’ˆæ‰€æŒ‡å‘çš„èŠ‚ç‚¹çš„ç›¸åŒå­èŠ‚ç‚¹
                Q.push(AC[u].vis[i]); // å‹å…¥é˜Ÿåˆ—
            }
            else // ä¸å­˜åœ¨è¿™ä¸ªå­èŠ‚ç‚¹
                AC[u].vis[i] = AC[AC[u].fail].vis[i];
            // å½“å‰èŠ‚ç‚¹çš„è¿™ä¸ªå­èŠ‚ç‚¹æŒ‡å‘å½“
            // å‰èŠ‚ç‚¹failæŒ‡é’ˆçš„è¿™ä¸ªå­èŠ‚ç‚¹
        }
    }
}
int AC_Query(string s) // ACè‡ªåŠ¨æœºåŒ¹é…
{
    int l = s.length();
    int now = 0, ans = 0;
    for (int i = 0; i < l; ++i)
    {
        now = AC[now].vis[s[i] - 'a'];                          // å‘ä¸‹ä¸€å±‚
        for (int t = now; t && AC[t].end != -1; t = AC[t].fail) // å¾ªç¯æ±‚è§£
        {
            ans += AC[t].end;
            AC[t].end = -1;
        }
    }
    return ans;
}
req(i,1,n) {
    {
        cin >> s;
        Build(s);
    }
    AC[0].fail = 0; // ç»“æŸæ ‡å¿—
    Get_fail();     // æ±‚å‡ºå¤±é…æŒ‡é’ˆ
    cin >> s;       // æ–‡æœ¬ä¸²
    cout << AC_Query(s) << endl;
}
```


## STL

### å®¹å™¨
```c
è¿™é‡Œåªæ€»ç»“string
string b = a + s; //å­—ç¬¦ä¸²æ‹¼æ¥
getchar(); //cin.get()
getline(cin, s);//è¯»å…¥ä¸‹ä¸€è¡Œçš„è¾“å…¥
const char *m = s.c_str() //stringè½¬æ¢charæ•°ç»„
.size() .length()
.push_back(x) 
.insert(pos,x)
.append(str) //åœ¨å­—ç¬¦ä¸²ç»“å°¾æ·»åŠ strå­—ç¬¦ä¸²
erase(iterator) //åˆ é™¤å­—ç¬¦ä¸²ä¸­æ‰€æŒ‡çš„å­—ç¬¦
erase(pos, len) //åˆ é™¤å­—ç¬¦ä¸²ä»poså¼€å§‹çš„lenä¸ªå­—ç¬¦
.clear()
.replace(pos,n,str) //æŠŠå½“å‰å­—ç¬¦ä¸²ä»ç´¢å¼•poså¼€å§‹çš„nä¸ªå­—ç¬¦æ›¿æ¢ä¸ºstr
.replace(pos, n, n1, c) //æŠŠå½“å‰å­—ç¬¦ä¸²ä»ç´¢å¼•poså¼€å§‹çš„nä¸ªå­—ç¬¦æ›¿æ¢ä¸ºn1ä¸ªå­—ç¬¦c
tolower(s[i]) //è½¬æ¢å°å†™
toupper(s[i]) //è½¬æ¢å¤§å†™
.substr(pos,n) //æˆªå–ä»posç´¢å¼•å¼€å§‹çš„nä¸ªå­—ç¬¦
sort(s.begin(),s.end());  //æŒ‰å­—ç¬¦çš„ASCIIç æ’åº
reverse(s.begin(), s.end());//å­—ç¬¦ä¸²åè½¬
.find(str,pos) //åœ¨posç´¢å¼•ä½ç½®å¼€å§‹æŸ¥æ‰¾å­ä¸²str,è¿”å›æ‰¾åˆ°çš„ä½ç½®ç´¢å¼•
```
### è¿­ä»£å™¨
```c
vector<int>::iterator it;//å®šä¹‰vectorçš„è¿­ä»£å™¨
it = a.begin();//è®©itæŒ‡å‘açš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œç›¸å½“äºä¸€ä¸ªæŒ‡é’ˆ
it++;//å‘å‰ç§»åŠ¨
cout<<*it<<endl;//è¾“å‡ºå…ƒç´ ï¼Œ2ï¼Œ*è¡¨ç¤ºè§£å¼•ç”¨
it = erase(x);//æ³¨æ„ç”¨è¿­ä»£å™¨è¿›è¡Œåˆ é™¤æ“ä½œæ—¶è¦å¯¹ité‡æ–°èµ‹å€¼
it = insert(x) //åŒä¸Šï¼Œåªå»ºç«‹ç”¨è¿­ä»£å™¨è¿›è¡Œè®¿é—®ï¼Œè€Œéæ“ä½œå…ƒç´ 
```
### å‡½æ•°
```c
accumulate(begin,end,intit); // æ±‚å’Œ
atoi(const char *) //å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºint
fill(begin,end,num) //å¯¹ä¸€ä¸ªåºåˆ—åˆå§‹åŒ–èµ‹å€¼
is_sorted(begin,end)//åˆ¤æ–­åºåˆ—æ˜¯å¦æœ‰åº
lower_bound(a.begin,a.end())/upper_bound(a.begin,a.end()) //äºŒåˆ†æŸ¥æ‰¾ã€‚å‰é¢æ‰¾>xï¼Œåé¢æ‰¾>=x
max_element()/min_element(a, a + n); //æ‰¾æœ€å¤§æœ€å°å€¼
max()/min()//å¤šä¸ªå…ƒç´ æœ€å¤§æœ€å°å€¼
minmax_element(begin, end) //è¿”å›åºåˆ—ä¸­æœ€å°å’Œæœ€å¤§å€¼ç»„æˆçš„pairçš„å¯¹åº”åœ°å€
nth_element(begin,nth,end) //å¯»æ‰¾ç¬¬åºåˆ—ç¬¬nå°çš„å€¼
next_permutation(begin, end) //æ±‚åºåˆ—çš„ä¸‹ä¸€ä¸ªæ’åˆ—
partial_sort(begin, mid, end) //éƒ¨åˆ†æ’åºbeginåˆ°mid
partial_sum(begin,end,back_inserter(a)) //å°†å‰ç¼€å’Œæ’å…¥åˆ°aåé¢
random_shuffle(a,a+n) //æ‰“ä¹±åºåˆ—é¡ºåº
reverse(begin,end) //åè½¬åºåˆ—
sort(begin, end,cmp);
to_string(int a) //å°†æ•°å­—è½¬åŒ–ä¸ºå­—ç¬¦ä¸²
unique(begin,end) //å»é‡ï¼Œå°†é‡å¤æ•°å­—ç§»åˆ°åºåˆ—æœ€åé¢
_gcd(a,b) //æ±‚æœ€å¤§å…¬çº¦æ•°
_lcm(a,b) //æ±‚æœ€å°å…¬å€æ•°

```
## ç»“æ„ä½“è¯¦è§£
```c
struct Point {
    int x;
    int y;
    // é»˜è®¤ public
    // æ„é€ å‡½æ•°
    Point(int _x=0, int _y=0): x(_x), y(_y) {}

    // æˆå‘˜å‡½æ•°ï¼ˆå¸¸æˆå‘˜ï¼‰
    double norm() const { return sqrt((double)x*x + (double)y*y); }

    // è¿ç®—ç¬¦é‡è½½ï¼ˆæ¯”è¾ƒï¼Œç”¨äº sortï¼‰
    bool operator<(Point const& other) const {
        if(x != other.x) return x < other.x;
        return y < other.y;
    }
};
//STLä½¿ç”¨
vector<Point> v;
v.emplace_back(1,2); // ç›´æ¥æ„é€ ï¼Œé¿å…æ‹·è´
sort(v.begin(), v.end()); // éœ€ operator< æˆ– comparator

//å¸¸ç”¨æ¨¡æ¿
//æ’åºå’Œå»é‡
struct Item { int a,b; };
vector<Item> a = ...;
sort(a.begin(), a.end(), [](auto const& p, auto const& q){
    if(p.a != q.a) return p.a < q.a;
    return p.b < q.b;
});
a.erase(unique(a.begin(), a.end(), [](auto const& p, auto const& q){
    return p.a==q.a && p.b==q.b;
}), a.end());
//ä½œä¸ºå›¾çš„è¾¹
struct Edge { int to; int w; };
vector<vector<Edge>> g(n);
g[u].push_back({v, w}); // aggregate init

//æ¨¡æ‹Ÿ(åœ¨acmæ‰“acm)
struct Team
{
    string name;
    int solved = 0;
    LL penalty = 0;
    array<bool, 13> done;
    array<int, 13> wrong;
    Team() { done.fill(false); wrong.fill(0);}
    Team(const string& s):name(s) {done.fill(false);wrong.fill(0);}
};
void Solve()
{
    int n;
    cin >> n;
    unordered_map<string, int> id;
    vector<Team> teams;
    teams.reserve(10000);
    req(i,0,n-1)
    {
        string s;
        char ch;
        int flag, t;
        cin >> s >> ch >> flag >> t;
        int pid = ch - 'A';
        if(!id.count(s))
        {
            id[s] = teams.size();
            teams.emplace_back(s);
        }
        Team &team = teams[id[s]];
        if(team.done[pid]) continue;
        if(flag == 0)
            team.wrong[pid] += 1;
        else{
            team.done[pid] = true;
            team.solved += 1;
            team.penalty += t + 20LL * team.wrong[pid];
        }
    }
    int best = 0;
    req(i,1,teams.size()-1)
    {
        if(teams[i].solved > teams[best].solved)
            best = i;
        else if(teams[i].solved == teams[best].solved && teams[i].penalty < teams[best].penalty)
            best = i;
    }
    cout << teams[best].name << " " << teams[best].solved << " " << teams[best].penalty << endl;
}
//ä¹’ä¹“çƒè®°åˆ†
void work(int lim)
{
    for(char p : s)
    {
        if(p == 'W') a++;
        else if(p == 'L') b++;
        if(max(a,b)>=lim && abs(a-b)>=2){
            cout << a << ":" << b << endl; a = 0; b = 0;
        }
    }
    cout << a << ":" << b << endl; a = 0; b = 0;
    cout << endl;
}
void Solve()
{
    
    while(cin >> m)
    {
        if (m == 'E')
            break;
        s += m;
    }
    work(11), work(21);
}
```
## æ‰“è¡¨
*æ‰“è¡¨çš„æ ‡å‡†æµç¨‹ï¼ˆæ­¥éª¤åŒ–ï¼‰*

1. æ˜ç¡®å˜é‡å’ŒèŒƒå›´ï¼šå…ˆé€‰ä¸€ä¸ªèƒ½ç©·å°½å°è§„æ¨¡è¡Œä¸ºçš„èŒƒå›´ï¼ˆæ¯”å¦‚ nâ‰¤20ã€å‚æ•° mâ‰¤50ï¼‰ã€‚
2. å†™æš´åŠ›/ç©·ä¸¾è§£æˆ–åŠ¨æ€è§„åˆ’ä½œä¸ºâ€œé‡‘æ ‡å‡†â€ï¼ˆbruteï¼‰ã€‚ä¿è¯å°è§„æ¨¡ä¸‹æ­£ç¡®æ€§ã€‚
3. ç”Ÿæˆè¡¨æ ¼ï¼šè‡³å°‘åŒ…å«è¾“å…¥ nã€è¾“å‡º ansï¼Œä»¥åŠå¯èƒ½çš„ä¸­é—´é‡ï¼ˆåˆ†è§£æ–¹å¼ã€ä½™æ•°ã€äºŒè¿›åˆ¶ã€å› å­ã€å·®åˆ†ã€gcd ç­‰ï¼‰ã€‚
4. è§‚å¯Ÿå¹¶å°è¯•å¤šç§è§†è§’ï¼šå·®åˆ†åºåˆ—ã€æ¯”å€¼ã€å› æ•°åˆ†è§£ã€äºŒè¿›åˆ¶ä½ã€æ¨¡ p ä½™æ•°ã€æœ€ä¼˜è§£ç»“æ„ï¼ˆæ„é€ æ³•ï¼‰ç­‰ã€‚
5. åŸºäºè¡¨æ ¼çŒœæƒ³è§„å¾‹ï¼ˆå½¢æ€ï¼šçº¿æ€§/å¤šé¡¹å¼/æŒ‡æ•°/å‘¨æœŸ/åˆ†å—/è´ªå¿ƒï¼‰ï¼Œå°è¯•è¯æ˜ï¼ˆäº¤æ¢è®ºè¯/æå€¼æ³•/å½’çº³/ä¸ç­‰å¼/åè¯ï¼‰ã€‚
6. ç”¨å¯¹æ‹æ‰©å¤§æµ‹è¯•ï¼šæŠŠçŒœæƒ³çš„ O(1) ç®—æ³•ä¸æš´åŠ›åœ¨æ›´å¤§éšæœºæµ‹è¯•ä¸Šå¯¹æ¯”ï¼Œæ‰¾åä¾‹å¹¶å›åˆ°ç¬¬ 3 æ­¥ä¿®æ­£çŒœæƒ³ã€‚

*è¡¨æ ¼è¯¥æ€ä¹ˆçœ‹ï¼ˆå¸¸ç”¨â€œå˜æ¢â€ï¼‰*

1. å·®åˆ†ï¼šdi = ai - ai-1â€‹ï¼Œåå¤åšå·®åˆ†å¯åˆ¤å®šå¤šé¡¹å¼ç¨‹åº¦ï¼ˆè‹¥ kk æ¬¡å·®åˆ†ä¸ºå¸¸æ•°ï¼Œåˆ™åŸåºåˆ—ä¸º kk æ¬¡å¤šé¡¹å¼ï¼‰ã€‚
2. æ¯”å€¼ï¼šai/ai-1â€‹ï¼Œçœ‹æ˜¯å¦è¶‹è¿‘å¸¸æ•°ï¼ˆæŒ‡æ•°å‹ï¼‰ã€‚
3. ä½™æ•°/å‘¨æœŸï¼šçœ‹ aiâ€Šmodâ€Šm æ˜¯å¦å‘¨æœŸæ€§ã€‚
4. äºŒè¿›åˆ¶/lowbitï¼šæ£€æŸ¥ aiâ€‹ çš„äºŒè¿›åˆ¶æ¨¡å¼ï¼ˆæ˜¯å¦ä¸ä½è¿ç®—ç›¸å…³ï¼‰ã€‚
5. å› å¼åˆ†è§£ / ç´ å› å­åˆ†å¸ƒï¼šè§‚å¯Ÿæ˜¯å¦æ€»æœ‰å¤§å› å­æˆ–å¤šæ¬¡å‡ºç°æŸç´ æ•°ã€‚
6. è´ªå¿ƒæ„é€ è·Ÿäº¤æ¢æ³•ï¼šè‹¥çŒœåˆ°æœ€ä¼˜ç”±è‹¥å¹²åŸºæœ¬å—æ„æˆï¼Œå°è¯•ç”¨äº¤æ¢è¯æ˜â€œæŠŠä¸¤ä¸ªå—æ¢æˆå…¶ä»–ç»„åˆæ˜¯å¦æ›´ä¼˜â€ã€‚

```python
//å…ˆå†™å‡ºæš´åŠ›åšæ³•åœ¨n<=3e4èƒ½è·‘å‡ºæ¥ O(n^2)
#!/usr/bin/env python3
import random, sys
ri = lambda a,b: random.randint(a,b)  # éšæœºæ•´æ•°
ra = lambda n,mn,mx: [ri(mn,mx) for _ in range(n)]  # éšæœºæ•°ç»„
rp = lambda n: random.sample(range(1,n+1), n)  # éšæœºæ’åˆ—
rs = lambda n: ''.join(chr(ri(97,122)) for _ in range(n))  # éšæœºå°å†™ä¸²
rb = lambda n: ''.join('01'[ri(0,1)] for _ in range(n))  # éšæœºäºŒè¿›åˆ¶ä¸²
def rt(n):  # éšæœºæ ‘
    e = []
    for i in range(2, n+1):
        e.append((ri(1,i-1), i))
    random.shuffle(e)
    return e
def rg(n,m,d=0):  # éšæœºå›¾
    e = set()
    while len(e) < m:
        u,v = ri(1,n),ri(1,n)
        if u==v: continue
        if not d and u>v: u,v=v,u
        e.add((u,v))
    return list(e)
# ====== å¿«é€Ÿç”Ÿæˆæµ‹è¯•æ•°æ® ======
if __name__ == "__main__":
    random.seed(123)  # å›ºå®šç§å­
       
    # 1. æ•°ç»„ + æŸ¥è¯¢
    # n, q = 100000, 100000
    # print(n, q)
    # print(*ra(n, 1, 10**9))
    # for _ in range(q):
    #     print(ri(1,n), ri(1,n))
 
    # 2. æ ‘
    # n = 100000
    # print(n)
    # for u,v in rt(n):
    #     print(u, v)
    
    # 3. å›¾
    # n, m = 1000, 2000
    # print(n, m)
    # for u,v in rg(n, m):
    #     print(u, v)
    
    # 4. å­—ç¬¦ä¸²
    # n = 100000
    # print(rs(n))
    
    # 5. æ’åˆ—
    # n = 100000
    # print(n)
    # print(*rp(n))
```

## <center>æ—¶é—´å¤æ‚åº¦é€ŸæŸ¥
```c
n â‰¤ 10: O(n!) å…¨æ’åˆ—
n â‰¤ 20: O(2^n) çŠ¶æ€å‹ç¼©
n â‰¤ 100: O(n^3) Floyd
n â‰¤ 1000: O(n^2) DP
n â‰¤ 10^5: O(nlogn) æ’åºã€çº¿æ®µæ ‘
n â‰¤ 10^6: O(n) åŒæŒ‡é’ˆã€å•è°ƒæ ˆ
```
## <center> å¸¸è§é”™è¯¯
1. **æ•´æ•°æº¢å‡º**ï¼šä¸­é—´ç»“æœå¯èƒ½æº¢å‡ºï¼ŒåŠæ—¶å–æ¨¡æˆ–å¼€long long
2. **æµ®ç‚¹æ•°ç²¾åº¦**ï¼šé¿å…ç›´æ¥æ¯”è¾ƒï¼Œä½¿ç”¨eps
3. **é€’å½’çˆ†æ ˆ**ï¼šDFSæ·±åº¦å¤§æ—¶è¦æ”¹éé€’å½’æˆ–è®¾ç½®æ ˆå¤§å°
4. **å¤šç»„æ•°æ®**ï¼šæ¸…ç©ºå…¨å±€å˜é‡å’Œå®¹å™¨
5. **ä¸‹æ ‡ä»0/1å¼€å§‹**ï¼šç»Ÿä¸€æ ‡å‡†